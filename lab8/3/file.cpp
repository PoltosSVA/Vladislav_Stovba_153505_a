#include "file.h"
#include "avtor.h"
#include "func.h"
#include "io.h"
#include <iostream>
using namespace std;

extern Library* books;
extern int N;


Library* LoadFile(Library* books) {
    // Загрузка содержимого из файла


    //b-Открыть в двоичном (непереведенном) режиме; переводы, включающие символы возврата каретки и перевода строки, подавляются.
    //r-Открывается для чтения. Если файл не существует или не может быть найден, fopen_sвызов не выполняется.
    //w-ткрывает пустой файл для записи. Если данный файл существует, его содержимое уничтожается.
    //r+-Открыт как для чтения, так и для письма. Файл должен существовать.
    //w+-Открывает пустой файл для чтения и записи. Если файл существует, его содержимое уничтожается.
    //fseek-С помощью fseek() можно переместить указатель положения в любую точку внутри файла и даже за его пределы после конца файла.
    //fwrite-возвра¬щает число записанных элементов. 
    //_chsize-расширяет файл или выполняет усечение файла, указанного аргументом handle, до величины size. 
    //_fileno-Она возвращает дескриптор файла указанного потока.
    //Файловый дескриптор — это неотрицательное целое число. Когда создается новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.






    Library* Load = 0; // Массив структур, куда будут записаны данные из файла
    FILE* z;  //Указатель на файл Чтобы прочитать или записать файлы, программе надо использовать указатели на файлы

    fopen_s(&z, "Input.txt", "rb+"); // открыть для чтения и записи
    //input название файла rb+тип доступа
    Library b;

    /* Функция fread() считывает count объектов (1) — каждый объект по sizeof(Library) символов в длину
         — из потока, указанного stream, и помещает их в символьный массив,
         указанный в b.Указатель пози­ции в файле (z)  продвигается вперед
         на количество считанных символов.
         */

    while (fread((char*)&b, sizeof(Library), 1, z)) {
        Load = (Library*)realloc(Load, ++N * sizeof(Library));
        Load[N - 1] = b;
    }

    if (N > 0)
        cout << "\nКниг загружено: " << N << endl;
    else
        cout << "\nФайл пуст";

    fclose(z);// Вызов fclose() освобождает блок управления файлом, связанный с потоком, и делает его доступным для повторного использования.

    free(books);

    return Load;
}

void ClearFile() {
    // Удаление содержимого файла

    FILE* z;
    fopen_s(&z, "Input.txt", "wb");

    // "wb" Создает двоичный файл для записи. (новый,т.е. чистит все содержимое)
    fclose(z);
}

void A_or_E(Library* books, int a) {
    // Добавление/ редактирование в каком-то месте в файлe

    FILE* z;
    fopen_s(&z, "Input.txt", "rb+");

    fseek(z, (a - 1) * (int)sizeof(Library), 0); //ставим курсор на нужную позицию, "0" - позиция начала файла
    fwrite((char*)&books[a - 1], sizeof(Library), 1, z);

    // (char*)&books[a - 1] - указатель на информацию записывамую в файл;
    // z -файловый указатель

    fclose(z);
}

void Del(Library* books, int Del) {
    // Смещение всех, стоящих после удаленного, на 1 позицию 

    if (N == 0 && Del == 0) // если мы удаляем последнюю структуру
        ClearFile();

    FILE* z;
    fopen_s(&z, "Input.txt", "rb+");

    for (int i = Del; i < N + 2; i++) {
        fseek(z, Del * (int)sizeof(Library), 0);
        fwrite((char*)&books[Del], sizeof(Library), 1, z);
    }

    fseek(z, 0, 0);

    // Обрезаем лишнее
    _chsize(_fileno(z), sizeof(Library) * N);

    //(sizeof(Library) * N) - новая длина в байтах.

    fclose(z);


}